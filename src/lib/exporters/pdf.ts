import { jsPDF } from "jspdf";
import { Documentation } from "@/types";

export function exportToPDF(doc: Documentation): jsPDF {
  const pdf = new jsPDF();
  let y = 20;
  const margin = 20;
  const pageWidth = pdf.internal.pageSize.getWidth();
  const maxWidth = pageWidth - margin * 2;

  function addPage() {
    pdf.addPage();
    y = 20;
  }

  function checkPageBreak(height: number) {
    if (y + height > pdf.internal.pageSize.getHeight() - 20) {
      addPage();
    }
  }

  function addTitle(text: string) {
    checkPageBreak(15);
    pdf.setFontSize(20);
    pdf.setFont("helvetica", "bold");
    pdf.text(text, margin, y);
    y += 12;
  }

  function addHeading(text: string) {
    checkPageBreak(12);
    pdf.setFontSize(14);
    pdf.setFont("helvetica", "bold");
    pdf.text(text, margin, y);
    y += 10;
  }

  function addSubheading(text: string) {
    checkPageBreak(10);
    pdf.setFontSize(12);
    pdf.setFont("helvetica", "bold");
    pdf.text(text, margin, y);
    y += 8;
  }

  function addText(text: string) {
    checkPageBreak(8);
    pdf.setFontSize(10);
    pdf.setFont("helvetica", "normal");
    const lines = pdf.splitTextToSize(text, maxWidth);
    for (const line of lines) {
      checkPageBreak(6);
      pdf.text(line, margin, y);
      y += 6;
    }
    y += 2;
  }

  function addCode(text: string) {
    checkPageBreak(8);
    pdf.setFontSize(9);
    pdf.setFont("courier", "normal");
    const lines = pdf.splitTextToSize(text, maxWidth);
    for (const line of lines) {
      checkPageBreak(5);
      pdf.text(line, margin + 5, y);
      y += 5;
    }
    y += 3;
    pdf.setFont("helvetica", "normal");
  }

  // Title page
  addTitle(`${doc.contractName} Documentation`);
  addText(`Address: ${doc.contractAddress}`);
  addText(`Network: ${doc.network}`);
  addText(`Generated: ${doc.generatedAt}`);
  y += 10;

  // Overview
  addHeading("Overview");
  addText(doc.overview);
  y += 5;

  // Functions
  if (doc.functions.length > 0) {
    addHeading("Functions");

    for (const func of doc.functions) {
      addSubheading(func.name);
      addCode(func.signature);
      addText(func.description);

      if (func.parameters.length > 0) {
        addText("Parameters:");
        for (const param of func.parameters) {
          addText(`  - ${param.name} (${param.type}): ${param.description}`);
        }
      }

      if (func.returns.length > 0) {
        addText("Returns:");
        for (const ret of func.returns) {
          addText(`  - ${ret.name || "result"} (${ret.type}): ${ret.description}`);
        }
      }

      y += 3;
    }
  }

  // Events
  if (doc.events.length > 0) {
    addHeading("Events");
    for (const event of doc.events) {
      addSubheading(event.name);
      addText(event.description);
      for (const param of event.parameters) {
        addText(`  - ${param.name} (${param.type})${param.indexed ? " [indexed]" : ""}: ${param.description}`);
      }
      y += 3;
    }
  }

  // Security Analysis
  if (doc.securityAnalysis) {
    addHeading("Security Analysis");
    addText(`Risk Level: ${doc.securityAnalysis.riskLevel.toUpperCase()}`);

    for (const finding of doc.securityAnalysis.findings) {
      addSubheading(`[${finding.severity.toUpperCase()}] ${finding.title}`);
      addText(finding.description);
    }

    if (doc.securityAnalysis.recommendations.length > 0) {
      addSubheading("Recommendations");
      for (const rec of doc.securityAnalysis.recommendations) {
        addText(`- ${rec}`);
      }
    }
  }

  // Footer
  addText("---");
  addText("Generated by ChainLens 2.0 - AI-Powered Smart Contract Documentation");

  return pdf;
}
