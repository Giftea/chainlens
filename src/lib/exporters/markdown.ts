// ============================================================
// ChainLens â€” Markdown Exporter
// Professional-quality markdown documentation export
// ============================================================

import { Documentation, GeneratedDocumentation } from "@/types";

export interface MarkdownExportOptions {
  includeTableOfContents?: boolean;
  includeMetadata?: boolean;
  includeTechnical?: boolean;
  includeSecurityAnalysis?: boolean;
  includeSourceCode?: boolean;
  sourceCode?: string;
}

const DEFAULT_OPTIONS: MarkdownExportOptions = {
  includeTableOfContents: true,
  includeMetadata: true,
  includeTechnical: true,
  includeSecurityAnalysis: true,
  includeSourceCode: false,
};

export function exportToMarkdown(
  doc: Documentation,
  gen?: GeneratedDocumentation,
  opts?: MarkdownExportOptions,
): string {
  const o = { ...DEFAULT_OPTIONS, ...opts };
  const lines: string[] = [];

  // ---- Title ----
  lines.push(`# ${doc.contractName}`);
  lines.push("");
  lines.push("> Smart Contract Documentation â€” Generated by ChainLens");
  lines.push("");

  // ---- Metadata ----
  if (o.includeMetadata) {
    lines.push("| Property | Value |");
    lines.push("|----------|-------|");
    lines.push(`| **Address** | \`${doc.contractAddress}\` |`);
    lines.push(`| **Network** | ${doc.network} |`);
    if (gen?.compiler) {
      lines.push(`| **Compiler** | ${gen.compiler} |`);
    }
    if (gen) {
      lines.push(`| **Complexity** | ${gen.complexity} |`);
      lines.push(`| **Lines of Code** | ${gen.linesOfCode} |`);
    }
    lines.push(`| **Functions** | ${doc.functions.length} |`);
    lines.push(`| **Events** | ${doc.events.length} |`);
    lines.push(`| **State Variables** | ${doc.stateVariables.length} |`);
    lines.push(`| **Generated** | ${doc.generatedAt} |`);
    lines.push(`| **Version** | ${doc.version} |`);
    lines.push("");
  }

  // ---- Table of Contents ----
  if (o.includeTableOfContents) {
    lines.push("## Table of Contents");
    lines.push("");
    lines.push("- [Executive Summary](#executive-summary)");
    if (gen?.technicalOverview) {
      lines.push("- [Technical Overview](#technical-overview)");
    }
    if (doc.functions.length > 0) {
      lines.push("- [Functions](#functions)");
      lines.push("  - [Read Functions](#read-functions)");
      lines.push("  - [Write Functions](#write-functions)");
    }
    if (doc.events.length > 0) {
      lines.push("- [Events](#events)");
    }
    if (doc.stateVariables.length > 0) {
      lines.push("- [State Variables](#state-variables)");
    }
    if (doc.modifiers.length > 0) {
      lines.push("- [Modifiers](#modifiers)");
    }
    if (gen?.designPatterns && gen.designPatterns.length > 0) {
      lines.push("- [Design Patterns](#design-patterns)");
    }
    if (gen?.inheritanceTree && gen.inheritanceTree.length > 0) {
      lines.push("- [Inheritance](#inheritance)");
    }
    if (gen?.externalCalls && gen.externalCalls.length > 0) {
      lines.push("- [External Calls](#external-calls)");
    }
    if (o.includeSecurityAnalysis && doc.securityAnalysis) {
      lines.push("- [Security Analysis](#security-analysis)");
    }
    if (gen?.gasOptimizations && gen.gasOptimizations.length > 0) {
      lines.push("- [Gas Optimizations](#gas-optimizations)");
    }
    if (gen?.useCases && gen.useCases.length > 0) {
      lines.push("- [Use Cases](#use-cases)");
    }
    lines.push("");
    lines.push("---");
    lines.push("");
  }

  // ---- Executive Summary ----
  lines.push("## Executive Summary");
  lines.push("");
  if (gen?.executiveSummary) {
    lines.push(gen.executiveSummary);
  } else {
    lines.push(doc.overview);
  }
  lines.push("");

  if (gen?.purpose) {
    lines.push("### Purpose");
    lines.push("");
    lines.push(gen.purpose);
    lines.push("");
  }

  // ---- Technical Overview ----
  if (o.includeTechnical && gen?.technicalOverview) {
    lines.push("## Technical Overview");
    lines.push("");
    lines.push(gen.technicalOverview);
    lines.push("");
  }

  // ---- Functions ----
  if (doc.functions.length > 0) {
    lines.push("## Functions");
    lines.push("");

    // Build a lookup from generated docs
    const genMap: Record<string, GeneratedDocumentation["functions"][number]> =
      {};
    if (gen?.functions) {
      for (const gf of gen.functions) {
        genMap[gf.name] = gf;
      }
    }

    const readFunctions = doc.functions.filter(
      (f) => f.stateMutability === "view" || f.stateMutability === "pure",
    );
    const writeFunctions = doc.functions.filter(
      (f) => f.stateMutability !== "view" && f.stateMutability !== "pure",
    );

    if (readFunctions.length > 0) {
      lines.push("### Read Functions");
      lines.push("");
      for (const func of readFunctions) {
        appendFunction(lines, func, genMap[func.name]);
      }
    }

    if (writeFunctions.length > 0) {
      lines.push("### Write Functions");
      lines.push("");
      for (const func of writeFunctions) {
        appendFunction(lines, func, genMap[func.name]);
      }
    }
  }

  // ---- Events ----
  if (doc.events.length > 0) {
    lines.push("## Events");
    lines.push("");

    const genEventMap: Record<
      string,
      GeneratedDocumentation["events"][number]
    > = {};
    if (gen?.events) {
      for (const ge of gen.events) {
        genEventMap[ge.name] = ge;
      }
    }

    for (const event of doc.events) {
      const ge = genEventMap[event.name];
      lines.push(`### \`${event.name}\``);
      lines.push("");
      lines.push(event.description);
      lines.push("");
      if (ge?.whenEmitted) {
        lines.push(`**Emitted when:** ${ge.whenEmitted}`);
        lines.push("");
      }
      if (ge?.purpose) {
        lines.push(`**Purpose:** ${ge.purpose}`);
        lines.push("");
      }

      if (event.parameters.length > 0) {
        lines.push("| Parameter | Type | Indexed | Description |");
        lines.push("|-----------|------|---------|-------------|");
        for (const param of event.parameters) {
          lines.push(
            `| \`${param.name}\` | \`${param.type}\` | ${
              param.indexed ? "Yes" : "No"
            } | ${param.description || "â€”"} |`,
          );
        }
        lines.push("");
      }
    }
  }

  // ---- State Variables ----
  if (doc.stateVariables.length > 0) {
    lines.push("## State Variables");
    lines.push("");
    lines.push("| Name | Type | Visibility | Properties | Description |");
    lines.push("|------|------|------------|------------|-------------|");
    for (const v of doc.stateVariables) {
      const props: string[] = [];
      if (v.isConstant) props.push("`constant`");
      if (v.isImmutable) props.push("`immutable`");
      lines.push(
        `| \`${v.name}\` | \`${v.type}\` | ${v.visibility} | ${
          props.join(", ") || "â€”"
        } | ${v.description || "â€”"} |`,
      );
    }
    lines.push("");
  }

  // ---- Modifiers ----
  if (doc.modifiers.length > 0) {
    lines.push("## Modifiers");
    lines.push("");
    for (const mod of doc.modifiers) {
      lines.push(`### \`${mod.name}\``);
      lines.push("");
      if (mod.description) {
        lines.push(mod.description);
        lines.push("");
      }
      if (mod.parameters.length > 0) {
        lines.push("**Parameters:**");
        lines.push("");
        for (const p of mod.parameters) {
          lines.push(
            `- \`${p.name}\` (\`${p.type}\`): ${p.description || "â€”"}`,
          );
        }
        lines.push("");
      }
    }
  }

  // ---- Design Patterns ----
  if (gen?.designPatterns && gen.designPatterns.length > 0) {
    lines.push("## Design Patterns");
    lines.push("");
    for (const pattern of gen.designPatterns) {
      lines.push(`- ${pattern}`);
    }
    lines.push("");
  }

  // ---- Inheritance ----
  if (gen?.inheritanceTree && gen.inheritanceTree.length > 0) {
    lines.push("## Inheritance");
    lines.push("");
    lines.push("```");
    lines.push(`${doc.contractName}`);
    for (const parent of gen.inheritanceTree) {
      lines.push(`  â””â”€â”€ ${parent}`);
    }
    lines.push("```");
    lines.push("");
  }

  // ---- External Calls ----
  if (gen?.externalCalls && gen.externalCalls.length > 0) {
    lines.push("## External Calls");
    lines.push("");
    lines.push("| Target Contract | Function | Purpose |");
    lines.push("|-----------------|----------|---------|");
    for (const call of gen.externalCalls) {
      lines.push(
        `| ${call.targetContract} | \`${call.function}\` | ${call.purpose} |`,
      );
    }
    lines.push("");
  }

  // ---- Security Analysis ----
  if (o.includeSecurityAnalysis && doc.securityAnalysis) {
    lines.push("## Security Analysis");
    lines.push("");
    lines.push(
      `**Risk Level:** ${riskEmoji(
        doc.securityAnalysis.riskLevel,
      )} ${doc.securityAnalysis.riskLevel.toUpperCase()}`,
    );
    lines.push("");

    if (doc.securityAnalysis.findings.length > 0) {
      lines.push("### Findings");
      lines.push("");
      for (const finding of doc.securityAnalysis.findings) {
        const emoji = severityEmoji(finding.severity);
        lines.push(
          `#### ${emoji} [${finding.severity.toUpperCase()}] ${finding.title}`,
        );
        lines.push("");
        lines.push(finding.description);
        if (finding.location) {
          lines.push("");
          lines.push(`*Location:* \`${finding.location}\``);
        }
        lines.push("");
      }
    }

    if (doc.securityAnalysis.recommendations.length > 0) {
      lines.push("### Recommendations");
      lines.push("");
      for (const rec of doc.securityAnalysis.recommendations) {
        lines.push(`- ${rec}`);
      }
      lines.push("");
    }

    if (gen?.securityConsiderations && gen.securityConsiderations.length > 0) {
      lines.push("### Additional Security Considerations");
      lines.push("");
      for (const note of gen.securityConsiderations) {
        lines.push(`- ${note}`);
      }
      lines.push("");
    }
  }

  // ---- Gas Optimizations ----
  if (gen?.gasOptimizations && gen.gasOptimizations.length > 0) {
    lines.push("## Gas Optimizations");
    lines.push("");
    for (const opt of gen.gasOptimizations) {
      lines.push(`- ${opt}`);
    }
    lines.push("");
  }

  // ---- Use Cases ----
  if (gen?.useCases && gen.useCases.length > 0) {
    lines.push("## Use Cases");
    lines.push("");
    for (let i = 0; i < gen.useCases.length; i++) {
      lines.push(`${i + 1}. ${gen.useCases[i]}`);
    }
    lines.push("");
  }

  // ---- Source Code ----
  if (o.includeSourceCode && o.sourceCode) {
    lines.push("## Source Code");
    lines.push("");
    lines.push("```solidity");
    lines.push(o.sourceCode);
    lines.push("```");
    lines.push("");
  }

  // ---- Footer ----
  lines.push("---");
  lines.push("");
  lines.push(
    "*Generated by [ChainLens](https://chainlens.dev) â€” AI-Powered Smart Contract Documentation on BNB Chain*",
  );

  return lines.join("\n");
}

// ---- Helpers ----

function appendFunction(
  lines: string[],
  func: Documentation["functions"][number],
  gen?: GeneratedDocumentation["functions"][number],
) {
  lines.push(`#### \`${func.name}\``);
  lines.push("");

  // Badges line
  const badges: string[] = [];
  badges.push(`**${func.visibility}**`);
  if (func.stateMutability !== "nonpayable") {
    badges.push(`\`${func.stateMutability}\``);
  }
  if (func.modifiers.length > 0) {
    for (const m of func.modifiers) {
      badges.push(`\`${m}\``);
    }
  }
  lines.push(badges.join(" Â· "));
  lines.push("");

  // Signature
  lines.push("```solidity");
  lines.push(func.signature);
  lines.push("```");
  lines.push("");

  // Description
  lines.push(func.description);
  lines.push("");

  // Business logic from AI
  if (gen?.businessLogic) {
    lines.push(`**Business Logic:** ${gen.businessLogic}`);
    lines.push("");
  }

  // Access control
  if (gen?.accessControl && gen.accessControl !== "None") {
    lines.push(`**Access Control:** ${gen.accessControl}`);
    lines.push("");
  }

  // Gas estimate
  if (gen?.gasEstimate) {
    lines.push(`**Gas Estimate:** ~${gen.gasEstimate}`);
    lines.push("");
  }

  // Parameters
  if (func.parameters.length > 0) {
    lines.push("**Parameters:**");
    lines.push("");
    lines.push("| Name | Type | Description |");
    lines.push("|------|------|-------------|");
    for (const param of func.parameters) {
      lines.push(
        `| \`${param.name}\` | \`${param.type}\` | ${
          param.description || "â€”"
        } |`,
      );
    }
    lines.push("");
  }

  // Returns
  if (func.returns.length > 0) {
    lines.push("**Returns:**");
    lines.push("");
    lines.push("| Name | Type | Description |");
    lines.push("|------|------|-------------|");
    for (const ret of func.returns) {
      lines.push(
        `| \`${ret.name || "â€”"}\` | \`${ret.type}\` | ${
          ret.description || "â€”"
        } |`,
      );
    }
    lines.push("");
  }

  // Security notes
  if (func.securityNotes.length > 0) {
    lines.push("**Security Notes:**");
    lines.push("");
    for (const note of func.securityNotes) {
      lines.push(`- ${note}`);
    }
    lines.push("");
  }

  // Risks from AI
  if (gen?.risks && gen.risks.length > 0) {
    lines.push("**Risks:**");
    lines.push("");
    for (const risk of gen.risks) {
      lines.push(`- ${risk}`);
    }
    lines.push("");
  }

  // Example
  if (gen?.example) {
    lines.push("**Example:**");
    lines.push("");
    lines.push("```solidity");
    lines.push(gen.example);
    lines.push("```");
    lines.push("");
  }

  lines.push("---");
  lines.push("");
}

function riskEmoji(level: string): string {
  switch (level) {
    case "low":
      return "ğŸŸ¢";
    case "medium":
      return "ğŸŸ¡";
    case "high":
      return "ğŸŸ ";
    case "critical":
      return "ğŸ”´";
    default:
      return "âšª";
  }
}

function severityEmoji(severity: string): string {
  switch (severity) {
    case "critical":
      return "ğŸ”´";
    case "high":
      return "ğŸŸ ";
    case "medium":
      return "ğŸŸ¡";
    case "low":
      return "ğŸ”µ";
    case "info":
      return "â„¹ï¸";
    default:
      return "âšª";
  }
}
