import { Documentation } from "@/types";

export function exportToMarkdown(doc: Documentation): string {
  const lines: string[] = [];

  lines.push(`# ${doc.contractName} Documentation`);
  lines.push("");
  lines.push(`**Address:** \`${doc.contractAddress}\``);
  lines.push(`**Network:** ${doc.network}`);
  lines.push(`**Generated:** ${doc.generatedAt}`);
  lines.push(`**Version:** ${doc.version}`);
  lines.push("");

  // Overview
  lines.push("## Overview");
  lines.push("");
  lines.push(doc.overview);
  lines.push("");

  // Functions
  if (doc.functions.length > 0) {
    lines.push("## Functions");
    lines.push("");

    for (const func of doc.functions) {
      lines.push(`### ${func.name}`);
      lines.push("");
      lines.push(`\`\`\`solidity`);
      lines.push(func.signature);
      lines.push(`\`\`\``);
      lines.push("");
      lines.push(func.description);
      lines.push("");

      if (func.parameters.length > 0) {
        lines.push("**Parameters:**");
        lines.push("");
        lines.push("| Name | Type | Description |");
        lines.push("|------|------|-------------|");
        for (const param of func.parameters) {
          lines.push(`| \`${param.name}\` | \`${param.type}\` | ${param.description} |`);
        }
        lines.push("");
      }

      if (func.returns.length > 0) {
        lines.push("**Returns:**");
        lines.push("");
        lines.push("| Name | Type | Description |");
        lines.push("|------|------|-------------|");
        for (const ret of func.returns) {
          lines.push(`| \`${ret.name || "-"}\` | \`${ret.type}\` | ${ret.description} |`);
        }
        lines.push("");
      }

      if (func.securityNotes.length > 0) {
        lines.push("**Security Notes:**");
        for (const note of func.securityNotes) {
          lines.push(`- ${note}`);
        }
        lines.push("");
      }
    }
  }

  // Events
  if (doc.events.length > 0) {
    lines.push("## Events");
    lines.push("");

    for (const event of doc.events) {
      lines.push(`### ${event.name}`);
      lines.push("");
      lines.push(event.description);
      lines.push("");

      if (event.parameters.length > 0) {
        lines.push("| Name | Type | Indexed | Description |");
        lines.push("|------|------|---------|-------------|");
        for (const param of event.parameters) {
          lines.push(
            `| \`${param.name}\` | \`${param.type}\` | ${param.indexed ? "Yes" : "No"} | ${param.description} |`
          );
        }
        lines.push("");
      }
    }
  }

  // State Variables
  if (doc.stateVariables.length > 0) {
    lines.push("## State Variables");
    lines.push("");
    lines.push("| Name | Type | Visibility | Description |");
    lines.push("|------|------|------------|-------------|");
    for (const v of doc.stateVariables) {
      lines.push(`| \`${v.name}\` | \`${v.type}\` | ${v.visibility} | ${v.description} |`);
    }
    lines.push("");
  }

  // Security Analysis
  if (doc.securityAnalysis) {
    lines.push("## Security Analysis");
    lines.push("");
    lines.push(`**Risk Level:** ${doc.securityAnalysis.riskLevel.toUpperCase()}`);
    lines.push("");

    if (doc.securityAnalysis.findings.length > 0) {
      lines.push("### Findings");
      lines.push("");
      for (const finding of doc.securityAnalysis.findings) {
        lines.push(`#### [${finding.severity.toUpperCase()}] ${finding.title}`);
        lines.push("");
        lines.push(finding.description);
        lines.push("");
      }
    }

    if (doc.securityAnalysis.recommendations.length > 0) {
      lines.push("### Recommendations");
      lines.push("");
      for (const rec of doc.securityAnalysis.recommendations) {
        lines.push(`- ${rec}`);
      }
      lines.push("");
    }
  }

  lines.push("---");
  lines.push("*Generated by ChainLens 2.0 - AI-Powered Smart Contract Documentation*");

  return lines.join("\n");
}
